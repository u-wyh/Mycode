/*
    这段代码旨在解决一个问题：对于一个数组，求不相邻元素的最大累加和
    dp[i]的含义是对于一个数组，求前i个元素中不相邻元素的最大累加和
    我们的答案是dp[n-1]（注意这个数组的长度是n）   int dp[n] 求dp[n-1]
    那么dp[i]就等于arr[i]加上  前面的 不相邻的  最大的 dp值
    如果前面的dp都是负数  那么dp[i]就等于arr[i]
*/

#include<stdio.h>
#define Max 100

static int dp[Max];

int main()
{
    int arr[Max];
    int i=0;
    while(scanf("%d",&arr[i++])==1);
    int n=i-1;
    dp[0]=arr[0];
    dp[1]=arr[1];
    for(int i=2;i<n;i++)
    {
        int temp=arr[i];
        for(int k=2;k<=i;k++)
        {
            int sum=0;
            sum=arr[i]+dp[i-k];
            if(sum>temp)
                temp=sum;
        }
        dp[i]=temp;
    }
    int max=dp[0];
    for(i=1;i<n;i++)
    {
        if(dp[i]>max)
            max=dp[i];
    }
    printf("%5d\n",max);
    return 0;
}

/*
扩展与延伸：环形数组最大累加和
    1.相邻元素之间的
        与链型数组相比只有一种特殊情况，就是最后面的和最前面的一起起作用了
        这种情况，我们反其道而行之，我们求数组最小累加和，然后用总值减去即可
        还要注意，如果所有的数都是负值，那么最大值是最大的一个数
        如果全是正值，那么最大值就是总和
        如果最后面的不与前面的一起起作用，那么就是求链形数组最大累加和
    2.不相邻元素之间的
        与链型数组相比只有一种特殊情况，就是最后面的和最前面的不可以一起起作用了
        这种情况，相当于是求  1.从下标2到n-2的不相邻元素之间的最大累加和加上第一个元素
                              2.从下标1到n-1的不相邻元素之间的最大累加和
        还要注意，如果所有的数都是负值，那么最大值是最大的一个数
        如果全是正值，那么最大值就是总和
*/
